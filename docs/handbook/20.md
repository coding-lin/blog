---
title: 字面量类型与联合类型
author: codinglin
date: 2023-2-24
categories:
  - 前端
tags:
  - TypeScript
sticky: 20
---

## 字面量类型与联合类型

```ts
interface Res {
  code: 10000 | 10001 | 50000;
  status: "success" | "failure";
  data: any;
}
```

### 字面量类型

你可能觉得很神奇，`"success"` 不是一个值吗？为什么它也可以作为类型？在 TypeScript 中，这叫做 **字面量类型（Literal Types）**，它代表着比原始类型更精确的类型，同时也是原始类型的子类型。

字面量类型主要包括**字符串字面量类型**、**数字字面量类型**、**布尔字面量类型**和**对象字面量类型**，它们可以直接作为类型标注：

```ts
const str: "linbudu" = "linbudu";
const num: 599 = 599;
const bool: true = true;
```

原始类型的值可以包括任意的同类型值，而字面量类型要求的是值级别的字面量一致。

### 联合类型

联合类型你可以理解为，它代表了一组类型的可用集合，只要最终赋值的类型属于联合类型的成员之一，就可以认为符合这个联合类型。

```ts
interface Tmp {
  mixed: true | string | 599 | {} | (() => {}) | (1 | 2);
}
```

这里有几点需要注意的：

- 对于联合类型中的函数类型，需要使用括号 `()` 包裹起来

- 函数类型并不存在字面量类型，因此这里的 `(() => {})` 就是一个合法的函数类型

- 你可以在联合类型中进一步嵌套联合类型，但这些嵌套的联合类型最终都会被展平到第一级中

### 对象字面量类型

对象字面量类型就是一个对象类型的值。当然，这也就意味着这个对象的值全都为字面量值：

```ts
interface Tmp {
  obj: {
    name: "linbudu";
    age: 18;
  };
}

const tmp: Tmp = {
  obj: {
    name: "linbudu",
    age: 18,
  },
};
```

需要注意的是，**无论是原始类型还是对象类型的字面量类型，它们的本质都是类型而不是值**。它们在编译时同样会被擦除，同时也是被存储在内存中的类型空间而非值空间。
