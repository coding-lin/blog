---
title: TypeScript 中对象的类型标注
author: codinglin
date: 2023-2-16
tags:
  - typescript
sticky: 18
---

## TypeScript 中对象的类型标注

在 TypeScript 中我们也需要特殊的类型标注来描述对象类型，即 `interface`，你可以理解为它代表了这个对象对外提供的接口结构。

首先我们使用 interface 声明一个结构，然后使用这个结构来作为一个对象的类型标注即可：

```ts
interface IDescription {
  name: string;
  age: number;
  male: boolean;
}

const obj1: IDescription = {
  name: "linbudu",
  age: 599,
  male: true,
};
```

除了声明属性以及属性的类型以外，我们还可以对属性进行修饰，常见的修饰包括**可选**（Optional） 与 **只读**（Readonly） 两种。

### 修饰接口属性

类似于上面的元组可选，在接口结构中同样通过 `?` 来标记一个属性为可选：

```ts
interface IDescription {
  name: string;
  age: number;
  male?: boolean;
  func?: Function;
}

const obj2: IDescription = {
  name: "linbudu",
  age: 599,
  male: true,
  // 无需实现 func 也是合法的
};
```

在这种情况下，即使你在 `obj2` 中定义了 `male` 属性，但当你访问 `obj2.male` 时，它的类型仍然会是 `boolean` | `undefined`，因为这是我们自己定义的类型。

假设新增一个可选的函数类型属性，然后进行调用：`obj2.func()`，此时将会产生一个类型报错：**不能调用可能是未定义的方法**。但可选属性标记不会影响你对这个属性进行赋值，如：

```ts
obj2.male = false;
obj2.func = () => {};
```

除了标记一个属性为可选以外，你还可以标记这个属性为只读：`readonly`。它的作用是**防止对象的属性被再次赋值**。

```ts
interface IDescription {
  readonly name: string;
  age: number;
}

const obj3: IDescription = {
  name: "linbudu",
  age: 599,
};

// 无法分配到 "name" ，因为它是只读属性
obj3.name = "林不渡";
```

可以使用只读标记来避免数组和对象被错误修改，但 `readonly` 并不会在实际运行时报错，因为 TypeScript 目前只能够帮助你在编译时做检查，类型信息在编译后都会被擦除。

其实在数组与元组层面也有着只读的修饰，但与对象类型有着两处不同：

- 你只能将整个数组/元组标记为只读，而不能像对象那样标记某个属性为只读。

- 一旦被标记为只读，那这个只读数组/元组的类型上，将不再具有 `push`、`pop` 等方法（即会修改原数组的方法），因此报错信息也将是**类型 xxx 上不存在属性“push”这种**。这一实现的本质是只读数组与只读元组的类型实际上变成了 `ReadonlyArray`，而不再是 `Array`。

为了更好地区分 `Object`、`object` 以及 `{}` 这三个具有迷惑性的类型，我们再做下总结：

- 在任何时候都不要使用 `Object` 以及类似的装箱类型(Boolean、Number、String、Symbol)。

- 当不确定某个变量的具体类型，但能确定它不是原始类型，可以使用 `object`。但更推荐使用 `Record<string, unknown>` 或 `Record<string, any>` 表示对象，`unknown[]` 或 `any[]` 表示数组，`(...args: any[]) => any` 表示函数这样。

- 同样要避免使用 `{}`。`{}` 意味着任何非 `null` / `undefined` 的值，从这个层面上看，使用它和使用 `any` 一样恶劣。
