(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{471:function(t,a,s){"use strict";s.r(a);var v=s(1),_=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"html、css-和-javascript-是如何变成页面的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html、css-和-javascript-是如何变成页面的"}},[t._v("#")]),t._v(" HTML、CSS 和 JavaScript 是如何变成页面的？")]),t._v(" "),a("ol",[a("li",[t._v("构建 DOM 树")])]),t._v(" "),a("p",[t._v("为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。")]),t._v(" "),a("p",[t._v("DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementsByTagName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"p"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("innerText "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"black"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("这行代码的作用是把第一个 "),a("code",[t._v("<p>")]),t._v(" 标签的内容修改为 black")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("样式计算")])]),t._v(" "),a("ul",[a("li",[t._v("把 CSS 转换为浏览器能够理解的结构")])]),t._v(" "),a("blockquote",[a("p",[t._v("CSS 样式来源主要有三种：1. 通过 link 引用的外部 CSS 文件 2. "),a("code",[t._v("<style>")]),t._v(" 标记内的 CSS 3. 元素的 style 属性内嵌的 CSS(内联样式)")])]),t._v(" "),a("p",[t._v("当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。")]),t._v(" "),a("ul",[a("li",[t._v("转换样式表中的属性值，使其标准化")])]),t._v(" "),a("blockquote",[a("p",[t._v("如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。")])]),t._v(" "),a("ul",[a("li",[t._v("计算出 DOM 树中每个节点的具体样式")])]),t._v(" "),a("blockquote",[a("p",[t._v("涉及到 CSS 的继承规则和层叠规则。CSS 继承就是每个 DOM 节点都包含有父节点的样式。")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("布局阶段")])]),t._v(" "),a("ul",[a("li",[t._v("创建布局树")])]),t._v(" "),a("blockquote",[a("p",[t._v("遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中，而不可见的节点会被布局树忽略掉。")])]),t._v(" "),a("ul",[a("li",[t._v("布局计算")])]),t._v(" "),a("blockquote",[a("p",[t._v("最后计算 DOM 元素的布局信息，使其都保存在布局树中")])]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("分层")])]),t._v(" "),a("p",[t._v("如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。")]),t._v(" "),a("p",[t._v("浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。")]),t._v(" "),a("p",[t._v("那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("拥有层叠上下文属性的元素会被提升为单独的一层，如明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等。"),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context",target:"_blank",rel:"noopener noreferrer"}},[t._v("更多"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[t._v("需要剪裁（clip）的地方也会被创建为图层")])])]),t._v(" "),a("blockquote",[a("p",[t._v("如文字所显示的区域肯定会超出了规定的范围，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域。出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。")])]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[t._v("图层绘制")])]),t._v(" "),a("p",[t._v("渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。"),a("strong",[t._v("绘制列表")]),t._v("只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。")]),t._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[t._v("栅格化（raster）操作")])]),t._v(" "),a("p",[t._v("合成线程会将图层划分为"),a("strong",[t._v("图块")]),t._v("（tile）。然后合成线程会按照视口附近的图块来优先生成"),a("strong",[t._v("位图")]),t._v("，实际生成位图的操作是由"),a("strong",[t._v("栅格化")]),t._v("来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。")]),t._v(" "),a("p",[t._v("通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫"),a("strong",[t._v("快速栅格化")]),t._v("，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。")]),t._v(" "),a("ol",{attrs:{start:"7"}},[a("li",[t._v("合成和显示")])]),t._v(" "),a("p",[t._v("一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。")]),t._v(" "),a("p",[t._v("浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。")]),t._v(" "),a("h3",{attrs:{id:"重排"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重排"}},[t._v("#")]),t._v(" 重排")]),t._v(" "),a("p",[t._v("通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫"),a("strong",[t._v("重排")]),t._v("。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。")]),t._v(" "),a("h3",{attrs:{id:"重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),a("p",[t._v("如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫"),a("strong",[t._v("重绘")]),t._v("。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。")]),t._v(" "),a("h3",{attrs:{id:"合成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成"}},[t._v("#")]),t._v(" 合成")]),t._v(" "),a("p",[t._v("如果你更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做"),a("strong",[t._v("合成")]),t._v("。")]),t._v(" "),a("p",[t._v("使用 CSS 的 transform 来实现动画效果，可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。")])])}),[],!1,null,null,null);a.default=_.exports}}]);