(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{466:function(v,_,t){"use strict";t.r(_);var a=t(1),e=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"聊一聊-babel"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#聊一聊-babel"}},[v._v("#")]),v._v(" 聊一聊 Babel")]),v._v(" "),_("p",[v._v("原文链接："),_("a",{attrs:{href:"https://juejin.cn/post/6844903849442934798",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://juejin.cn/post/6844903849442934798"),_("OutboundLink")],1)]),v._v(" "),_("p",[v._v("Babel 大概分为三大部分：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("解析：将代码(其实就是字符串)转换成 AST(抽象语法树)")])]),v._v(" "),_("li",[_("p",[v._v("转换：访问 AST 的节点进行"),_("strong",[v._v("变换操作")]),v._v("生成新的 AST")])]),v._v(" "),_("li",[_("p",[v._v("生成：以新的 AST 为基础生成代码")])])]),v._v(" "),_("h3",{attrs:{id:"解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解析"}},[v._v("#")]),v._v(" 解析")]),v._v(" "),_("p",[v._v("代码解析，也就是我们常说的 Parser，用于将一段代码(文本)解析成一个数据结构。")]),v._v(" "),_("p",[v._v("文本转换成 AST 有两个关键步骤：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("词法分析：将代码(字符串)分割为 token 流，即语法单元数组(语法单元包括数字、括号、标识符、运算符、注释等)")])]),v._v(" "),_("li",[_("p",[v._v("语法分析：分析 token 流(上面生成的数组)并生成 AST(语法分析很复杂,因为要分析各种语法的可能性)")])])]),v._v(" "),_("blockquote",[_("p",[v._v("在我们 parser 的过程中，应该换一个角度看待代码，我们平时工作用的代码，本质是就是字符串或者一段文本，它没有任何意义，是 JavaScript 引擎赋予了它意义，所以我们在解析过程中代码只是一段字符串。")])]),v._v(" "),_("h3",{attrs:{id:"转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#转换"}},[v._v("#")]),v._v(" 转换")]),v._v(" "),_("p",[v._v("在 Babel 中我们最常使用的就是代码转换，大家常用的 Babel 插件就是定义代码转换规则而生的，而代码解析和生成这一头一尾主要是由 Babel 负责。")]),v._v(" "),_("p",[v._v("比如我们要用 babel 做一个 React 转小程序的转换器，babel 工作流程的粗略情况是这样的：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("babel 将 React 代码解析为抽象语法树")])]),v._v(" "),_("li",[_("p",[v._v("开发者利用 babel 插件定义转换规则，根据原本的抽象语法树生成一个符合小程序规则的新抽象语法树")])]),v._v(" "),_("li",[_("p",[v._v("babel 则根据新的抽象语法树生成代码，此时的代码就是符合小程序规则的新代码")])])]),v._v(" "),_("p",[v._v("例如 Taro 就是用 babel 完成的小程序语法转换，转换代码的关键就是根据当前的抽象语法树，以我们定义的规则生成新的抽象语法树，"),_("strong",[v._v("转换的过程就是生成新抽象语法树的过程")]),v._v("。")]),v._v(" "),_("p",[v._v("抽象语法树是一个树状数据结构，我们要生成新语法树，那么一定需要访问 AST 上的节点，因此我们需要一个工具(遍历器 "),_("code",[v._v("traverser")]),v._v(")来遍历抽象语法树的节点。")]),v._v(" "),_("p",[v._v("我们之前的遍历器 "),_("code",[v._v("traverser")]),v._v(" 接收两个参数，一个是 "),_("code",[v._v("ast")]),v._v(" 节点对象，一个是 "),_("code",[v._v("visitor")]),v._v("，"),_("code",[v._v("visitor")]),v._v(" 本质是挂载不同方法的 JavaScript 对象，"),_("code",[v._v("visitor")]),v._v(" 也叫做访问者，它会访问 "),_("code",[v._v("ast")]),v._v(" 上每个节点，然后根据针对不同节点用相应的方法做出不同的转换。")]),v._v(" "),_("h3",{attrs:{id:"生成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生成"}},[v._v("#")]),v._v(" 生成")]),v._v(" "),_("p",[v._v("生成代码这一步实际上是根据我们转换后的抽象语法树来生成新的代码，接受一个对象 "),_("code",[v._v("ast")]),v._v("，通过递归生成最终的代码。")])])}),[],!1,null,null,null);_.default=e.exports}}]);